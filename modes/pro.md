# Режим «Профи (долгострой)»

**Для кого:** масштабируемый проект, долгая разработка с заделом на расширяемость, тестами и полным учётом состояния.

## Цель

Долгий проект с заделом. Полный набросок, детальные этапы с критериями приёмки, архитектура, тесты. Полное ведение файлов: Docs/DEV_STATE (текущее + контекст), Docs/DEV_PLAN (план), Docs/DEV_LOG/ (итерации с именами iteration-NN-YYYYMMDD-HHMM.md, скриншоты).

## Уточняющие вопросы

- **Перед планом:** да, подробные. Уточнить жанр, все механики, экраны, системы, стиль, платформу, расширяемость, приоритеты.
- **Перед фичей:** да, **если есть сомнения**. Уточнить детали реализации, поведение, граничные случаи, какие данные в SO, какой UI. Если всё понятно из плана — делать без вопросов.
- **По ходу:** при неясностях — обязательно спросить. Лучше спросить, чем переделывать.
- Можно отключить/включить по просьбе пользователя.

## Воркфлоу

1. Подробные уточняющие вопросы → полное понимание проекта.
2. Полный набросок (системы, экраны, данные, расширяемость).
3. Детальные этапы с чеклистами и критериями приёмки.
4. Reuse-first (по умолчанию): перед реализацией фичи (1) проверить встроенные возможности Unity и установленные пакеты; (2) при необходимости искать готовые механики и библиотеки на **GitHub** и **в интернете**. Сравнить 1–3 варианта и выбрать. Если фича слишком маленькая и простая — писать вручную. **Перед каждой фичей — уточнить если есть сомнения.**
5. Полное ведение файлов: Docs/DEV_STATE + Docs/DEV_PLAN + Docs/DEV_LOG/ (итерации).

## Reuse-first (поиск готовых решений)

- По умолчанию **включено** (переключатель в `Docs/DEV_CONFIG.md` → «Поиск готовых решений»).
- Сначала проверить готовое (встроенное в Unity + уже установленные пакеты), затем при необходимости искать на GitHub и в интернете. Приоритет поиска: **UPM/пакет** → **GitHub/открытый код** → ассет → референс-код.
- Критерии выбора (обязательные): лицензия, поддержка/обновления, совместимость с Unity/платформой, размер/риски зависимости.
- Фиксация решения: записать в `Docs/ARCHITECTURE.md` (что выбрали и почему) + в текущий файл итерации в `Docs/DEV_LOG/` (имя: iteration-NN-YYYYMMDD-HHMM.md) (что сделали).

## Проверки и тесты

- **Агент обязан сам проверять:** почти на каждую задачу внутри фичи + проверка на фичу целиком. Запуск Play Mode, скриншоты игры (не только сцены), попытка поиграть (кнопки, сценарий). В редакторе + скриншоты + чеклисты.
- **Автотесты по умолчанию включены.** По желанию пользователя можно отключить. При старте в режиме Профи уточнить: «Автотесты включены по умолчанию; отключить?»
- **QA на фичу:** при запросе настроек (создание Docs/DEV_CONFIG) агент **обязан спросить** пользователя: «QA на фичу: включить (после каждой фичи вы проверяете по шагам, агент ждёт ОК) или только финальная QA в конце?» Значение записать в Docs/DEV_CONFIG.md. Если включена — после каждой фичи агент пишет QA-чеклист по шаблону (шаги + ожидаемое + граничные случаи + «Проверка агентом» + «Проверка QA»). Агент не переходит к следующей фиче без ОК пользователя.
- **Финальная QA:** обязательно в конце — полный QA-чеклист (шаги + ожидаемое поведение + граничные случаи + **Проверка агентом** + **Проверка QA**). См. reference.md → «Шаблон QA-чеклиста».

## Набросок

Полный: жанр, механики, все экраны/сцены, основные системы (ввод, сохранения, UI, звук), данные и расширяемость.

## Этапы

Детальные этапы с чеклистами и критериями приёмки. По каждому этапу — файлы/сцены/префабы, чеклист проверки, критерии «готово».

## Файлы состояния

Полный формат. `Docs/DEV_STATE.md` — контекст + текущая задача + блокеры + ближайшие (обновлять при каждом действии). `Docs/DEV_PLAN.md` — все задачи с чекбоксами, статистика. `Docs/DEV_LOG/iteration-NN-YYYYMMDD-HHMM.md` — полные записи: дата, результат, файлы, скриншоты с описаниями. Обновлять при каждом действии.

## Стиль кода

**Архитектура** — SO для всех данных + сервисы/интерфейсы, рефакторинг, расширяемость. Юнит-тесты (или автотесты) по умолчанию да. **Все настройки в SO** (NpcData, GameFightData, UiData и т.д.). См. [SKILL.md](../SKILL.md) — правило «настройки только в SO».

### Комментарии в коде (Профи)

- **XML-документация (docstring) обязательна** для: классов, публичных методов, публичных полей/свойств, интерфейсов.
- **Обычных комментариев (`//`) НЕ писать.** Код должен быть самодокументируемым.
- **Исключения — только:**
  - `// TODO:` — задача на будущее.
  - `// HACK:` / `// WORKAROUND:` — явное неочевидное место, которое требует пояснения почему так.
  - `// NOTE:` — критически неочевидная логика, где без пометки следующий разработчик не поймёт.
  - Комментарии в SO-классах для пояснения настроек (через `[Tooltip]` или `//` рядом с полем).
- **Никаких** «очевидных» комментариев вроде `// увеличиваем счётчик`, `// вызываем метод`.

### Логирование (Профи)

- **Обильное и уместное.** Логировать ключевые события, смену состояний, действия, ошибки, предупреждения.
- Формат: `Debug.Log($"[Фича.Класс.Метод] описание с параметрами")`.
  - Пример: `Debug.Log($"[Combat.HealthComponent.TakeDamage] Damage={amount}, HP={_currentHealth}")`.
- `Debug.LogError` — ошибки. `Debug.LogWarning` — подозрительные ситуации.
- Не логировать в Update каждый кадр.

Подробнее и примеры: [tools/code-writing.md](../tools/code-writing.md).

## Пример наброска (Профи)

```
Жанр: RPG с пошаговыми боями.
Цель: масштабируемый проект с заделом на контент.

Системы:
- Бой: пошаговый, способности, эффекты. SO: AbilityData, StatusEffectData.
- Инвентарь: предметы, экипировка. SO: ItemData, EquipmentData.
- Диалоги: NPC, квесты. SO: DialogueData, QuestData.
- Прогрессия: уровни, опыт. SO: LevelCurveData.

Экраны: MainMenu, WorldMap, Battle, Inventory, Dialogue, Settings.

Данные: все параметры боя, предметов, NPC, квестов, UI — в SO.
Расширяемость: новый враг = новый EnemyData asset, новый квест = новый QuestData asset.
Тесты: бой, инвентарь, прогрессия.
```

## Пример этапов (Профи)

```
Этап 1: Архитектура — GameManager, SceneLoader, ServiceLocator.
  Критерий: сцены переключаются, сервисы доступны. Тест: SceneLoadTest.

Этап 2: Боевая система.
  2.1: Модель боя (BattleManager, TurnSystem). Тест: TurnOrderTest.
  2.2: Способности (AbilitySystem + AbilityData SO). Тест: DamageCalcTest.
  2.3: UI боя (BattleUI, HP-бары, выбор способности). Проверка в редакторе.
  Критерий фичи: бой проходит от начала до конца, параметры из SO.

Этап 3: Инвентарь.
  3.1: Модель (Inventory, ItemData SO). Тест: InventoryAddRemoveTest.
  3.2: UI инвентаря. Проверка в редакторе.
  Критерий: предметы добавляются/удаляются, данные из SO.

Этап 4: Диалоги и квесты (DialogueSystem, QuestSystem, SO-данные).
Этап 5: Мир, навигация, интеграция всех систем.
Этап 6: Полировка, баланс через SO, финальные тесты.
```

## Чеклист режима «Профи»

- [ ] Подробные уточняющие вопросы → полный набросок (системы, экраны, данные). Уточнить: автотесты? Уточняющие вопросы? **Обязательно спросить про QA на фичу** и записать в Docs/DEV_CONFIG.md.
- [ ] Подробный план: детальные этапы с чеклистами и критериями приёмки.
- [ ] **Перед каждой фичей** — если есть сомнения или неоднозначность, задать уточняющий вопрос пользователю.
- [ ] Реализация по этапам: архитектура, SO, тесты. **Проверка почти на каждую задачу в фиче и на фичу целиком.**
- [ ] После каждой фичи/задачи агент сам проверяет: Play Mode, скриншоты игры, попытка поиграть. Если QA на фичу включена — написать QA-шаги, дождаться ОК.
- [ ] Запуск автотестов по мере разработки (если не отключено пользователем).
- [ ] Файлы состояния (DEV_STATE/PLAN/LOG) вести в полном формате; обновлять при каждом действии; скриншоты с датами.
- [ ] **Финальная QA** — составить QA-чеклист по шаблону (шаги, ожидаемое, «Проверка агентом» — заполнить, «Проверка QA» — пустая для QA по просьбе агента).
